# 이분 탐색 (+ 파라미터 탐색) 알고리즘 문제 정리

## 목차

1. [BOJ_2805 나무 자르기](#1-boj_2805-나무-자르기-백준-링크-소스-코드)
2. [BOJ_12015 가장 긴 증가하는 부분 수열2](#2-boj_12015-가장-긴-증가하는-부분-수열2-백준-링크-소스-코드)
3. [SWEA_10507 영어 공부](#3-swea_10507-영어-공부-swea-링크-소스-코드)
4. [SWEA_9843 촛불 이벤트](#4-swea_9843-촛불-이벤트-swea-링크-소스-코드)
5. [SWEA_11446 사탕 가방](#5-swea_11446-사탕-가방-swea-링크-소스-코드)

## 1. BOJ_2805 나무 자르기 [(백준 링크)](https://www.acmicpc.net/problem/2805) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/2000/Main_2805.java)

### 문제 요약

나무들의 높이가 주어졌을 때, 어떤 높이에서 나무를 잘라야 원하는 길이의 나무를 베어갈 수 있는지 계산하는 문제

### 풀이 아이디어

나무의 높이를 정렬한 뒤 각 나무의 높이를 기준으로 절단기를 설정했을 때 가져 갈 수 있는 나무의 길이를 계산하여 (O(N))  
나무의 길이가 짧으면 높이가 낮은 나무를 기준으로 절단기를 설정하고, 나무의 길이가 길면 높이가 높은 나무를 기준으로 절단기를 설정하도록 하여 이진 탐색으로 최적의 높이를 찾도록 수행. (O(log N))  
N <= 1000000 이므로 O(N log N)의 시간복잡도에서 충분히 잘 돌아갈 것이라 판단.  
이후 결과로 반환 받은 Index값에 해당하는 나무의 높이를 기준으로 절단기를 잘랐을 때 길이가 부족하면 높이를 1씩 줄여가며 원하는 길이에 도달하도록 탐색을 수행.

## 2. BOJ_12015 가장 긴 증가하는 부분 수열2 [(백준 링크)](https://www.acmicpc.net/problem/12015) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/12000/Main_12015.java)

### 문제 요약

수열이 주어졌을 때, 그 중 가장 긴 증가하는 부분 수열의 길이를 구하는 문제

### 풀이 아이디어

14003 가장 긴 증가하는 부분 수열5 문제의 하위 호환. 길이만 구하면 되므로 쉬움

## 3. SWEA_10507 영어 공부 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AXNQOb3avD0DFAXS) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/10000/Solution_10507.java)

### 문제 요약

두 수 사이에 p개 만큼의 숫자를 추가할 수 있을 때, 1씩 증가하는 연속된 수열의 최대 길이를 구하는 문제

### 풀이 아이디어

파라미터 탐색을 통해 각 Index에서 다른 영어 공부를 한 날짜의 Index를 연결하기 위해 p에서 사용해야 하는 날짜의 개수를 먼저 계산한 뒤, 이분 탐색을 통해 연결할 때 사용한 날짜의 개수가 전체 p보다 작거나 같다면 더 큰수를 탐색하도록 파라미터 탐색을 수행하면 풀 수 있다.

## 4. SWEA_9843 촛불 이벤트 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AXGBKzuaPOoDFAXR) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/9000/Solution_9843.java)

### 문제 요약

수 N이 주어졌을 때, K \* (K + 1) / 2 = N을 만족하는 K를 찾는 문제

### 풀이 아이디어

입력의 범위가 1부터 10<sup>18</sup>까지 이므로, 해당 범위 내에서 파라미터 탐색을 통해 K \* (K + 1) / 2의 값을 계산하여 해당 값이 N보다 작거나 같도록 하는 가장 큰 K값을 계산하여 해결하였다.  
이분 탐색을 수행할 때 무조건 배열 내부에서 탐색하는 문제만 풀어왔기 때문에, 단순 숫자만 주어졌을 때도 사용할 수 있음을 생각하는 데 시간이 걸렸던 문제이다.

## 5. SWEA_11446 사탕 가방 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AXdHxTNqC2IDFAS5) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/11000/Solution_11446.java)

### 문제 요약

전체 사탕의 종류와 종류별 사탕 개수가 주어졌을 때, 동일한 구성으로 M개의 사탕을 포함하는 사탕 가방을 만들 때 최대 몇 개의 사탕 가방을 만들 수 있는지 계산하는 문제.

### 풀이 아이디어

입력의 범위가 1부터 10<sup>18</sup>까지 이므로, 해당 범위 내에서 파라미터 탐색을 통해 종류별 사탕 개수를 현재 사탕 가방 수로 나눠 해당 종류의 사탕을 넣을 수 있는 개수를 모두 더했을 때 M보다 작다면 사탕이 부족한 것이므로 사탕 가방의 수를 줄여서 탐색한다.  
M보다 크거나 같은 경우 해당 사탕 가방의 개수만큼은 만들어낼 수 있는 것이므로 해당 사탕 가방의 개수를 범위에 포함하여 그 보다 더 많은 개수의 사탕 가방을 구성할 수 있는지 다시 탐색을 수행한다.  
`이러한 문제의 경우 재귀적으로 구현했을 때 재귀가 너무 깊어져 Stack 메모리가 터질 수 있으므로, 가급적 while 반복문으로 구현하는 것을 추천한다.`
