# 투 포인터 알고리즘 문제 정리 (슬라이딩 윈도우 문제 포함)

## 목차

1. [BOJ_16472 고냥이](#1-boj_16472-고냥이-백준-링크-소스-코드)
2. [BOJ_1806 부분합](#1-boj_1806-부분합-백준-링크-소스-코드)

## 1. BOJ_16472 고냥이 [(백준 링크)](https://www.acmicpc.net/problem/16472) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/16000/Main_16472.java)

### 문제 요약

사용할 수 있는 알파벳의 개수가 제한되어 있을 때, 해당 개수만큼의 알파벳으로 구성된 가장 긴 문자열을 찾는 문제

### 풀이 아이디어

1. 문자열 탐색 도중 새로운 알파벳이 나타났을 때  
   1-1. 현재 인식한 알파벳이 최대 개수보다 적다면 해당 알파벳을 인식하고 계속 진행  
   1-2. 현재 인식한 알파벳이 최대 개수라면 인식한 알파벳의 개수가 감소할 때까지 문자열의 길이를 감소
2. 이미 인식한 알파벳인 경우 문자열의 길이를 늘리고 계속 진행

## 2. BOJ_1806 부분합 [(백준 링크)](https://www.acmicpc.net/problem/1806) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1806.java)

### 문제 요약

길이 N인 수열이 주어지고, 연속된 부분 수열의 합이 주어진 값 S 이상이 되는 최소 길이를 구하는 문제

### 풀이 아이디어

투 포인터 i, j에서 j를 늘리면 부분 수열의 길이가 늘어나고, i를 늘리면 부분 수열의 길이가 감소하는데, j를 늘려서 부분 수열의 합이 S 이상이 되면 i를 S 미만이 될 때까지 증가하면서 가장 짧은 길이를 갱신하면 해결 가능하다.
