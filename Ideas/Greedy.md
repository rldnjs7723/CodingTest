# 그리디 알고리즘 문제 정리

## 목차

1. [BOJ_2138 전구와 스위치](#1-boj_2138-전구와-스위치-백준-링크-소스-코드)
2. [BOJ_1080 행렬](#2-boj_1080-행렬-백준-링크-소스-코드)

## 1. BOJ_2138 전구와 스위치 [(백준 링크)](https://www.acmicpc.net/problem/2138) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/2000/Main_2138.java)

### 문제 요약

현재 전구에 달려 있는 스위치를 켜면 해당 전구의 왼쪽, 오른쪽에 위치한 전구도 함께 켜질 때 목표 전구 상태로 만드는 최소 스위치 조작 횟수를 계산하는 문제

### 풀이 아이디어

가장 왼쪽에 위치한 전구의 스위치를 켜고 / 끄는 상황을 고정한 뒤, 이전 전구를 올바르게 켜도록 현재 스위치를 조작하는 방식.  
`이전에 조작했던 스위치를 절대 다시 조작하지 않기 떄문에 그리디의 핵심 아이디어가 적용`

## 2. BOJ_1080 행렬 [(백준 링크)](https://www.acmicpc.net/problem/1080) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1080.java)

### 문제 요약

3 x 3 크기의 부분 행렬에 위치한 모든 값을 0 -> 1, 1 -> 0으로 반전시킬 때 목표 행렬로 만들 수 있는 최소 뒤집는 횟수를 계산하는 문제

### 풀이 아이디어

반드시 3 x 3의 크기를 만족하는 경우만 뒤집을 수 있기 때문에 0행 0열에 위치한 값은 반드시 1행 1열에서 뒤집어야 수정할 수 있음.  
따라서 3 x 3을 만족하는 범위 내에서 현재 행, 열의 왼쪽 위가 목표 상태로 전환되도록 뒤집어야 목표 행렬로 바꿀 수 있음.
이 때 각 위치에서 뒤집는 순서는 전혀 상관이 없고, 두 번 뒤집으면 안 뒤집은 상태와 동일하므로, 어떤 것을 먼저 뒤집더라도 최적해를 찾을 수 있음을 보장
