# 그리디 알고리즘 문제 정리

## 목차

1. [BOJ_2138 전구와 스위치](#1-boj_2138-전구와-스위치-백준-링크-소스-코드)
2. [BOJ_1080 행렬](#2-boj_1080-행렬-백준-링크-소스-코드)
3. [BOJ_3109 빵집](#3-boj_3109-빵집-백준-링크-소스-코드)
4. [BOJ_1202 보석 도둑](#4-boj_1202-보석-도둑-백준-링크-소스-코드)

## 1. BOJ_2138 전구와 스위치 [(백준 링크)](https://www.acmicpc.net/problem/2138) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/2000/Main_2138.java)

### 문제 요약

현재 전구에 달려 있는 스위치를 켜면 해당 전구의 왼쪽, 오른쪽에 위치한 전구도 함께 켜질 때 목표 전구 상태로 만드는 최소 스위치 조작 횟수를 계산하는 문제

### 풀이 아이디어

가장 왼쪽에 위치한 전구의 스위치를 켜고 / 끄는 상황을 고정한 뒤, 이전 전구를 올바르게 켜도록 현재 스위치를 조작하는 방식.  
`이전에 조작했던 스위치를 절대 다시 조작하지 않기 떄문에 그리디의 핵심 아이디어가 적용`

## 2. BOJ_1080 행렬 [(백준 링크)](https://www.acmicpc.net/problem/1080) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1080.java)

### 문제 요약

3 x 3 크기의 부분 행렬에 위치한 모든 값을 0 -> 1, 1 -> 0으로 반전시킬 때 목표 행렬로 만들 수 있는 최소 뒤집는 횟수를 계산하는 문제

### 풀이 아이디어

반드시 3 x 3의 크기를 만족하는 경우만 뒤집을 수 있기 때문에 0행 0열에 위치한 값은 반드시 1행 1열에서 뒤집어야 수정할 수 있음.  
따라서 3 x 3을 만족하는 범위 내에서 현재 행, 열의 왼쪽 위가 목표 상태로 전환되도록 뒤집어야 목표 행렬로 바꿀 수 있음.
이 때 각 위치에서 뒤집는 순서는 전혀 상관이 없고, 두 번 뒤집으면 안 뒤집은 상태와 동일하므로, 어떤 것을 먼저 뒤집더라도 최적해를 찾을 수 있음을 보장

## 3. BOJ_3109 빵집 [(백준 링크)](https://www.acmicpc.net/problem/3109) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/3000/Main_3109.java)

### 문제 요약

빵집 주변의 상태가 빈 칸, 벽으로 주어졌을 때 가장 왼쪽의 열에서 가장 오른쪽 열까지 이어지는 파이프의 최대 개수를 계산하는 문제

### 풀이 아이디어

각각의 행에서 다음 열에 파이프를 설치할 위치를 탐색할 때  
오른쪽 위 -> 오른쪽 -> 오른쪽 아래 순서로 탐색을 수행하여 설치한다면,  
가장 위의 행에서부터 파이프를 설치했을 때 최적해를 구할 수 있음을 보장한다는 사실을 경험적으로 발견함 (증명하지는 못 함)

## 4. BOJ_1202 보석 도둑 [(백준 링크)](https://www.acmicpc.net/problem/1202) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1202.java)

### 문제 요약

N 개의 보석의 무게, 가격이 주어지고 K개의 가방에 각각 담을 수 있는 무게가 주어질 때 훔칠 수 있는 보석의 최대 가격을 계산하는 문제. (단, 각 가방에는 한 개의 보석만 담을 수 있다.)

### 풀이 아이디어

각 가방에 한 개의 보석만 담을 수 있으므로 보석을 가치 기준 내림차순으로 정렬하여, 해당 보석보다 무게가 크면서 가장 작은 무게를 담을 수 있는 가방에 넣는 `Greedy`한 방식으로 탐색을 진행하면 된다는 것을 발견.  
다만 무게가 크면서 가장 작은 무게를 찾기 위해서는 무게를 오름차순으로 정렬한 뒤, 이분 탐색으로 어떤 가방에 넣을지 찾아야 함.  
이 때, 이미 사용한 가방은 더 이상 사용할 수 없기 때문에 처음에는 ArrayList에 넣어 불필요한 가방은 remove하는 방식으로 구현하려 했으나 N, K <= 300000으로, O(N^2)의 시간 복잡도가 소요되기 때문에 시간 초과가 발생.  
따라서 사용된 가방을 표시하기 위해 `Union Find로 사용된 가방의 Index에서 다음 가방의 위치를 표시하는 객체를 서로 묶어서 O(log N)의 시간 복잡도로 다음 가방의 Index를 얻을 수 있도록 탐색하여 시간 초과를 해결`
