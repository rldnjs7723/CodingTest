# 백트래킹 알고리즘 문제 정리

## 목차

1. [BOJ_2239 스도쿠](#1-boj_2239-스도쿠-백준-링크-소스-코드)
2. [BOJ_6987 월드컵](#2-boj_6987-월드컵-백준-링크-소스-코드)
3. [SWEA_1767 프로세서 연결하기](#3-swea_1767-프로세서-연결하기-백준-링크-소스-코드)

## 1. BOJ_2239 스도쿠 [(백준 링크)](https://www.acmicpc.net/problem/2239) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/2000/Main_2239.java)

### 문제 요약

빈 칸이 있는 스도쿠가 주어졌을 때, 스도쿠를 완성하여 출력하는 문제

### 풀이 아이디어

각 행과 열, 3x3 보드에서 1 ~ 9가 존재하는지의 여부를 비트로 나타내어 총 27개의 비트마스크를 사용.  
1행 1열부터 시작하여 1부터 차례대로 아직 각 행, 열, 보드에서 존재하지 않는 숫자를 선택하고,  
만약 1부터 9까지 탐색했는데 넣을 수 있는 숫자를 찾지 못했다면 잘못된 해이므로 `이전 행, 열로 되돌아가서` 다른 수를 해당 칸에 입력하도록 구현.

## 2. BOJ_6987 월드컵 [(백준 링크)](https://www.acmicpc.net/problem/6987) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/6000/Main_6987.java)

### 문제 요약

6개의 나라가 축구 경기에서 승, 무, 패 한 결과가 주어졌을 때 해당 결과가 현실적으로 나올 수 있는 경우인지 판단하는 문제

### 풀이 아이디어

각각의 나라에서 승의 개수만큼 다른 나라를 Next Permutation을 이용한 조합으로 선택한 뒤, 다른 나라에서 패배한 개수를 감소 시킴. 이러한 과정을 반복했을 때 승의 개수와 패의 개수가 0이 아니라면 실현 불가능한 예제.
나머지 과정을 무승부의 개수에 대해서도 수행하여 실현 가능한 예제인지 판별.  
`다만 앞서 조합에서 패배한 나라를 선택할 때 사용한 나라는 이미 경기를 수행했기 때문에, 이후 조합에서는 등장하면 안 됨. 비트마스킹으로 방문 체크를 수행하여 각 나라끼리 중복된 경기를 하지 않도록 확인해주어야 함`

## 3. SWEA_1767 프로세서 연결하기 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV4suNtaXFEDFAUf) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/1000/Solution_1767.java)

### 문제 요약

[SWEA_1461](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/1000/Solution_1461.java)과 동일한 문제. 프로세서에서의 코어 위치가 주어졌을 때 가장자리까지 전선을 연결했을 때, 연결된 코어 개수가 최대가 되고, 전선의 길이는 최소가 될 때의 전선 길이를 출력하는 문제.

### 풀이 아이디어

문제의 조건 중에서 각 코어를 연결하는 전선이 서로 교차해서는 안 된다는 조건이 있는데, `이러한 조건에 따라 코어 중에서는 아무런 전선도 연결하지 않는 경우의 수까지 고려해야 한다`. 따라서 사방 탐색까지만 수행하지 않고, 전선을 연결하지 않는 경우까지 추가로 탐색을 수행해야 한다.  
기본 문제 해결 아이디어는 각 코어에서 모든 방향으로 전선을 연결해보고 전선이 겹치는 경우에는 롤백해서 다른 방향을 탐색하도록 하는 Backtracking 기법이 사용되었다.
