# 다이나믹 프로그래밍 문제 정리

## 목차

1. [BOJ_10942 팰린드롬?](#1-boj_10942-팰린드롬-백준-링크-소스-코드)
2. [BOJ_12852 1로 만들기 2](#2-boj_12852-1로-만들기-2-백준-링크-소스-코드)
3. [BOJ_10844 쉬운 계단 수](#3-boj_10844-쉬운-계단-수-백준-링크-소스-코드)
4. [BOJ_11049 행렬 곱셈 순서](#4-boj_11049-행렬-곱셈-순서-백준-링크-소스-코드)
5. [SWEA_1248 공통조상](#5-swea_1248-공통조상-swea-링크-소스-코드)

## 1. BOJ_10942 팰린드롬? [(백준 링크)](https://www.acmicpc.net/problem/10942) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10942.java)

### 문제 요약

정수 배열이 주어졌을 때 특정 인덱스 사이의 값들이 팰린드롬인지 확인하는 문제

### 풀이 아이디어

처음에는 팰린드롬 문제라서 Stack과 Queue를 사용해 pop과 poll을 사용한 결과가 같은지 확인하려 했으나, 테스트 케이스가 여러 개 주어져서 시간이 오래 걸려 다이나믹 프로그래밍을 활용하게 됨.  
길이가 1인 팰린드롬부터 N인 팰린드롬까지 순차적으로 계산하며 자신보다 길이가 2 더 짧은 팰린드롬의 결과를 바탕으로 자신이 팰린드롬인지 판단하도록 구현

## 2. BOJ_12852 1로 만들기 2 [(백준 링크)](https://www.acmicpc.net/problem/12852) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/12000/Main_12852.java)

### 문제 요약

주어진 정수 N에 대해 3으로 나누어 떨어지면 3으로 나누고, 2로 나누어 떨어지면 2로 나누고, 1을 뺄 수 있는 연산을 수행할 수 있을 때 1로 만드는 최소 연산의 개수를 계산하는 문제

### 풀이 아이디어

정수 N에서부터 3개의 연산을 모두 수행하며 이전에 저장된 값보다 더 적게 연산을 사용해서 도달한 부분을 갱신하여 1까지 도달한 뒤 1에 저장된 값을 출력

## 3. BOJ_10844 쉬운 계단 수 [(백준 링크)](https://www.acmicpc.net/problem/10844) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10844.java)

### 문제 요약

수열의 길이 N이 주어졌을 때, 12345와 같이 현재 자리에서 인접한 수와 값이 1만 차이나는 수로만 이루어진 수열의 개수를 계산하는 문제.

### 풀이 아이디어

0 ~ 9까지 각각 개수를 나눠서 저장하고, 각 배열에 숫자가 0 ~ 9로 끝나는 수열의 개수를 저장하는 방식으로 점화식을 통해 계산. (현재 숫자가 1이면 이전에 0과 2로 끝난 수열의 개수의 합으로 표현)

```java
dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
```

## 4. BOJ_11049 행렬 곱셈 순서 [(백준 링크)](https://www.acmicpc.net/problem/11049) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/11000/Main_11049.java)

### 문제 요약

유명한 행렬 곱셈 순서 계산 문제. 행렬을 계산할 때 괄호를 어떻게 두어야 행렬 계산이 최솟값이 되는지 계산하는 문제.

### 풀이 아이디어

ABC의 행렬 계산 경우의 수는 (AB)C와 A(BC)가 존재하는데, 두 경우를 비교했을 때 최솟값을 저장하도록 점화식을 작성.

## 5. SWEA_1248 공통조상 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15PTkqAPYCFAYD) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/1000/Solution_1248.java)

### 문제 요약

트리의 부모-자식 관계가 주어졌을 때 두 노드의 [최소 공통 조상(Lowest Common Ancester, LCA)](https://github.com/rldnjs7723/CodingTest#lca-lowest-common-ancestor-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)을 찾고 해당 공통 조상을 루트 노드로 하는 서브 트리의 크기를 출력하는 문제

### 풀이 아이디어

문제의 시간 초과 자체는 20초 정도로, 트리를 구성한 다음 O(N) 시간에 해결하도록 구현해도 문제가 없으나, 학습 목적으로 LCA 알고리즘을 적용하여 해결함.

```java
parent[i][j] = parent[parent[i][j - 1]][j - 1]
```

위와 같은 기본 점화식을 바탕으로 다이나믹 프로그래밍 기법을 사용하여 비교 대상인 두 노드의 깊이를 메꿀 때 O(log N) 시간이 소요되도록 구현하였다.  
나머지 해당 조상 노드를 루트로 하는 서브 트리의 크기는 재귀를 이용한 DFS를 통해 갱신하는 방식으로 구현.
