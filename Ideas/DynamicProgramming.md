# 다이나믹 프로그래밍 문제 정리

## 목차

1. [BOJ_10942 팰린드롬?](#1-boj_10942-팰린드롬-백준-링크-소스-코드)
2. [BOJ_12852 1로 만들기 2](#2-boj_12852-1로-만들기-2-백준-링크-소스-코드)
3. [BOJ_10844 쉬운 계단 수](#3-boj_10844-쉬운-계단-수-백준-링크-소스-코드)
4. [BOJ_11049 행렬 곱셈 순서](#4-boj_11049-행렬-곱셈-순서-백준-링크-소스-코드)
5. [SWEA_1248 공통조상](#5-swea_1248-공통조상-swea-링크-소스-코드)
6. [BOJ_15481 그래프와 MST](#6-boj_15481-그래프와-mst-백준-링크-소스-코드)
7. [SWEA_1855 영준이의 진짜 BFS](#7-swea_1855-영준이의-진짜-bfs-swea-링크-소스-코드)
8. [BOJ_2098 외판원 순회](#8-boj_2098-외판원-순회-백준-링크-소스-코드)
9. [BOJ_1102 발전소](#9-boj_1102-발전소-백준-링크-소스-코드)
10. [BOJ_1562 계단 수](#10-boj_1562-계단-수-백준-링크-소스-코드)
11. [BOJ_20188 등산 마니아](#11-boj_20188-등산-마니아-백준-링크-소스-코드)

## 1. BOJ_10942 팰린드롬? [(백준 링크)](https://www.acmicpc.net/problem/10942) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10942.java)

### 문제 요약

정수 배열이 주어졌을 때 특정 인덱스 사이의 값들이 팰린드롬인지 확인하는 문제

### 풀이 아이디어

처음에는 팰린드롬 문제라서 Stack과 Queue를 사용해 pop과 poll을 사용한 결과가 같은지 확인하려 했으나, 테스트 케이스가 여러 개 주어져서 시간이 오래 걸려 다이나믹 프로그래밍을 활용하게 됨.  
길이가 1인 팰린드롬부터 N인 팰린드롬까지 순차적으로 계산하며 자신보다 길이가 2 더 짧은 팰린드롬의 결과를 바탕으로 자신이 팰린드롬인지 판단하도록 구현

## 2. BOJ_12852 1로 만들기 2 [(백준 링크)](https://www.acmicpc.net/problem/12852) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/12000/Main_12852.java)

### 문제 요약

주어진 정수 N에 대해 3으로 나누어 떨어지면 3으로 나누고, 2로 나누어 떨어지면 2로 나누고, 1을 뺄 수 있는 연산을 수행할 수 있을 때 1로 만드는 최소 연산의 개수를 계산하는 문제

### 풀이 아이디어

정수 N에서부터 3개의 연산을 모두 수행하며 이전에 저장된 값보다 더 적게 연산을 사용해서 도달한 부분을 갱신하여 1까지 도달한 뒤 1에 저장된 값을 출력

## 3. BOJ_10844 쉬운 계단 수 [(백준 링크)](https://www.acmicpc.net/problem/10844) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10844.java)

### 문제 요약

수열의 길이 N이 주어졌을 때, 12345와 같이 현재 자리에서 인접한 수와 값이 1만 차이나는 수로만 이루어진 수열의 개수를 계산하는 문제.

### 풀이 아이디어

0 ~ 9까지 각각 개수를 나눠서 저장하고, 각 배열에 숫자가 0 ~ 9로 끝나는 수열의 개수를 저장하는 방식으로 점화식을 통해 계산. (현재 숫자가 1이면 이전에 0과 2로 끝난 수열의 개수의 합으로 표현)

```java
dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
```

## 4. BOJ_11049 행렬 곱셈 순서 [(백준 링크)](https://www.acmicpc.net/problem/11049) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/11000/Main_11049.java)

### 문제 요약

유명한 행렬 곱셈 순서 계산 문제. 행렬을 계산할 때 괄호를 어떻게 두어야 행렬 계산이 최솟값이 되는지 계산하는 문제.

### 풀이 아이디어

ABC의 행렬 계산 경우의 수는 (AB)C와 A(BC)가 존재하는데, 두 경우를 비교했을 때 최솟값을 저장하도록 점화식을 작성.

## 5. SWEA_1248 공통조상 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15PTkqAPYCFAYD) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/1000/Solution_1248.java)

### 문제 요약

트리의 부모-자식 관계가 주어졌을 때 두 노드의 [최소 공통 조상(Lowest Common Ancester, LCA)](https://github.com/rldnjs7723/CodingTest#lca-lowest-common-ancestor-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)을 찾고 해당 공통 조상을 루트 노드로 하는 서브 트리의 크기를 출력하는 문제

### 풀이 아이디어

문제의 시간 초과 자체는 20초 정도로, 트리를 구성한 다음 O(N) 시간에 해결하도록 구현해도 문제가 없으나, 학습 목적으로 LCA 알고리즘을 적용하여 해결함.

```java
parent[i][j] = parent[parent[i][j - 1]][j - 1]
```

위와 같은 기본 점화식을 바탕으로 다이나믹 프로그래밍 기법을 사용하여 비교 대상인 두 노드의 깊이를 메꿀 때 O(log N) 시간이 소요되도록 구현하였다.  
나머지 해당 조상 노드를 루트로 하는 서브 트리의 크기는 재귀를 이용한 DFS를 통해 갱신하는 방식으로 구현.

## 6. BOJ_15481 그래프와 MST [(백준 링크)](https://www.acmicpc.net/problem/15481) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/15000/Main_15481.java)

### 문제 요약

간선이 주어졌을 때 각 간선을 포함하는 MST의 가중치 합을 각각 출력하는 문제

### 풀이 아이디어

크루스칼 알고리즘의 시간 복잡도는 |E| log |E|, |E|개의 간선에 대해 반복해야 하므로 단순 반복하면 E <= 200,000 이므로, 40,000,000,000번의 연산으로 시간 초과가 발생.  
따라서 전체 간선을 통해 임의로 1번 노드를 루트로 하는 MST를 구성한 뒤, 두 노드 사이의 [최소 공통 조상 (LCA)](https://github.com/rldnjs7723/CodingTest#lowest-common-ancestor-lca-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)을 찾아 조상 노드와 각 노드 사이에 위치한 간선들의 가중치 중에서 최댓값을 가지는 간선을 제거한 후 두 노드를 연결하는 간선을 추가하면 해결할 수 있다.  
단순히 최소 공통 조상을 찾아 O(N)의 시간으로 처리하면 시간 초과가 뜰 것이라 예상했으나, Java의 경우 추가 시간으로 통과가 되었다. 이후 재채점을 통해 시간 초과가 발생한다면 각 공통 조상까지 가는 위치에 존재하는 모든 가중치 최댓값을 기록하는 방식으로 시간 복잡도를 줄일 수 있을 것이다.

## 7. SWEA_1855 영준이의 진짜 BFS [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5LnipaDvwDFAXc) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/1000/Solution_1855.java)

### 문제 요약

각 노드의 부모 노드가 주어졌을 때, 노드 번호의 크기가 작은 자식 먼저 탐색하는 BFS를 수행할 때 거치는 간선 개수를 카운트 하는 문제

### 풀이 아이디어

앞서 배운 LCA를 다이나믹 프로그래밍으로 구하는 알고리즘을 사용하면 쉽게 풀 수 있다.  
`다만 노드의 개수가 이번 처럼 5,000개를 넘어가는 경우 Stack 메모리가 터질 수 있다는 점`  
`LCA를 찾을 때 무조건 O(log N)의 시간 복잡도를 가지도록 탐색을 수행해야 한다는 점`을 주의해야 한다.

## 8. BOJ_2098 외판원 순회 [(백준 링크)](https://www.acmicpc.net/problem/2098) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/2000/Main_2098.java)

### 문제 요약

NP-Hard로 잘 알려진 외판원 순회 문제. N <= 16인 범위에서 모든 도시를 방문하는 최소 거리를 계산한다.

### 풀이 아이디어

[Traveling Salesman Problem (TSP, 외판원 문제)](https://github.com/rldnjs7723/CodingTest#traveling-salesman-problem-tsp-%EC%99%B8%ED%8C%90%EC%9B%90-%EB%AC%B8%EC%A0%9C)에 문제 풀이 팁, 알고리즘 구현에 대해 설명하였다.  
비트필드를 통한 다이나믹 프로그래밍 문제로, 시간 복잡도를 줄이기 위해 여러 기술이 들어가야 했다.

## 9. BOJ_1102 발전소 [(백준 링크)](https://www.acmicpc.net/problem/1102) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1102.java)

### 문제 요약

외판원 순회 문제와 비슷한 문제. 다만, 외판원 순회와 다르게 이미 체크된 영역으로 돌아갈 수 있으며 (자기 자신 포함), 그 때에는 비용이 0이다.

### 풀이 아이디어

[Traveling Salesman Problem (TSP, 외판원 문제)](https://github.com/rldnjs7723/CodingTest#traveling-salesman-problem-tsp-%EC%99%B8%ED%8C%90%EC%9B%90-%EB%AC%B8%EC%A0%9C)와 거의 비슷한 문제였기 때문에, 비트필드를 이용한 다이나믹 프로그래밍으로 푸는 문제이다.  
다만, 발전소가 처음부터 켜져 있는 경우 이미 켜져있는 곳으로 돌아갈 수 있기 때문에 다시 돌아가는 코드를 작성해주고, 다이나믹 프로그래밍 자체는 발전소를 방문한 위치의 비트마스크로 수행해주면서 이미 방문한 발전소를 체크하는 비트마스크를 추가해야 한다.

## 10. BOJ_1562 계단 수 [(백준 링크)](https://www.acmicpc.net/problem/1562) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1562.java)

### 문제 요약

[BOJ_10844 쉬운 계단 수](#3-boj_10844-쉬운-계단-수-백준-링크-소스-코드)의 어려운 버전. 0 ~ 9까지의 모든 수가 포함된 길이 N인 계단 수를 카운트하는 문제

### 풀이 아이디어

비트필드를 이용한 다이나믹 프로그래밍의 비재귀 형태 구현 방식.  
쉬운 계단 수에서와 동일하게 가장 마지막에 추가한 수에 따라 다음 길이의 계단 수를 추가해주면 되는데, 0 ~ 9까지의 수가 모두 있는지 확인하기 위해 비트마스킹이 필요.

## 11. BOJ_20188 등산 마니아 [(백준 링크)](https://www.acmicpc.net/problem/20188) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/20000/Main_20188.java)

### 문제 요약

이진 트리의 i번 노드에서 j번 노드로 갈 때 (i < j) 거치는 중복 없는 간선의 개수(다양성)를 세는 문제.

### 풀이 아이디어

1. 1번 노드에서 다른 모든 노드로 가는 간선의 개수를 셀 때는 모든 노드의 깊이를 더하면 된다.
2. 트리를 구성할 때 각 노드에서 형제 노드를 서브 트리로 했을 때의 노드 수를 같이 계산.
3. 점화식:  
   (현재 노드의 다른 모든 노드로 가는 간선의 개수) = (부모 노드의 다른 모든 노드로 가는 간선의 개수) + (현재 노드의 형제 노드를 서브 트리르 했을 때의 노드 수)
4. i < j인 경우를 고려하지 않고 각 노드에서 모든 다른 노드로 가는 간선의 개수를 센 뒤에 2로 나눠주면,  
   어차피 각 노드에서 루트 노드를 거쳐서 가는 경로가 같기 때문에 동일한 결과를 출력할 수 있다.
