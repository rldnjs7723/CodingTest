# 다이나믹 프로그래밍 문제 정리

## 목차

1. [BOJ_10942 팰린드롬?](#1-boj_10942-팰린드롬-백준-링크-소스-코드)
2. [BOJ_12852 1로 만들기 2](#2-boj_12852-1로-만들기-2-백준-링크-소스-코드)
3. [BOJ_10844 쉬운 계단 수](#3-boj_10844-쉬운-계단-수-백준-링크-소스-코드)
4. [BOJ_11049 행렬 곱셈 순서](#4-boj_11049-행렬-곱셈-순서-백준-링크-소스-코드)

## 1. BOJ_10942 팰린드롬? [(백준 링크)](https://www.acmicpc.net/problem/10942) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10942.java)

### 문제 요약

정수 배열이 주어졌을 때 특정 인덱스 사이의 값들이 팰린드롬인지 확인하는 문제

### 풀이 아이디어

처음에는 팰린드롬 문제라서 Stack과 Queue를 사용해 pop과 poll을 사용한 결과가 같은지 확인하려 했으나, 테스트 케이스가 여러 개 주어져서 시간이 오래 걸려 다이나믹 프로그래밍을 활용하게 됨.  
길이가 1인 팰린드롬부터 N인 팰린드롬까지 순차적으로 계산하며 자신보다 길이가 2 더 짧은 팰린드롬의 결과를 바탕으로 자신이 팰린드롬인지 판단하도록 구현

## 2. BOJ_12852 1로 만들기 2 [(백준 링크)](https://www.acmicpc.net/problem/12852) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/12000/Main_12852.java)

### 문제 요약

주어진 정수 N에 대해 3으로 나누어 떨어지면 3으로 나누고, 2로 나누어 떨어지면 2로 나누고, 1을 뺄 수 있는 연산을 수행할 수 있을 때 1로 만드는 최소 연산의 개수를 계산하는 문제

### 풀이 아이디어

정수 N에서부터 3개의 연산을 모두 수행하며 이전에 저장된 값보다 더 적게 연산을 사용해서 도달한 부분을 갱신하여 1까지 도달한 뒤 1에 저장된 값을 출력

## 3. BOJ_10844 쉬운 계단 수 [(백준 링크)](https://www.acmicpc.net/problem/10844) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10844.java)

### 문제 요약

수열의 길이 N이 주어졌을 때, 12345와 같이 현재 자리에서 인접한 수와 값이 1만 차이나는 수로만 이루어진 수열의 개수를 계산하는 문제.

### 풀이 아이디어

0 ~ 9까지 각각 개수를 나눠서 저장하고, 각 배열에 숫자가 0 ~ 9로 끝나는 수열의 개수를 저장하는 방식으로 점화식을 통해 계산. (현재 숫자가 1이면 이전에 0과 2로 끝난 수열의 개수의 합으로 표현)

```java
dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
```

## 4. BOJ_11049 행렬 곱셈 순서 [(백준 링크)](https://www.acmicpc.net/problem/11049) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/11000/Main_11049.java)

### 문제 요약

유명한 행렬 곱셈 순서 계산 문제. 행렬을 계산할 때 괄호를 어떻게 두어야 행렬 계산이 최솟값이 되는지 계산하는 문제.

### 풀이 아이디어

ABC의 행렬 계산 경우의 수는 (AB)C와 A(BC)가 존재하는데, 두 경우를 비교했을 때 최솟값을 저장하도록 점화식을 작성.
