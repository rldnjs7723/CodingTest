# 트라이 문제 정리

## 목차

1. [BOJ_27652 AB](#1-boj_27652-ab-백준-링크-소스-코드)
2. [BOJ_7432 디스크 트리](#2-boj_7432-디스크-트리-백준-링크-소스-코드)
3. [BOJ_16901 XOR MST](#3-boj_16901-xor-mst-백준-링크-소스-코드)
4. [BOJ_10538 빅 픽쳐](#4-boj_10538-빅-픽쳐-백준-링크-소스-코드)

## 1. BOJ_27652 AB [(백준 링크)](https://www.acmicpc.net/problem/27652) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/27000/Main_27652.java)

### 문제 요약

두 문자열 집합 A, B가 있을 때 A, B에 문자열을 넣고 삭제하는 쿼리가 주어진다. A의 원소에서는 접두사를, B의 원소에서는 접미사를 합쳤을 때 입력 받은 문자열이 되는 경우의 수를 계산하는 쿼리 또한 주어진다.

### 풀이 아이디어

전형적인 트라이 문제. 입력은 영어 소문자로만 들어오기 때문에 문자열의 각 문자를 각각의 노드에 저장하는 방식으로 트라이를 구성해주면 된다. 다만, B의 경우 접미사를 사용해야 하기 때문에 원래 입력 받은 문자열을 역순으로 트라이에 넣어주는 방식으로 구현했다.  
경우의 수를 계산할 때는 반복되는 계산을 피하기 위해 각각의 접두사에 해당하는 개수를 한 번에 계산한 뒤 배열로 리턴하여 계산하도록 구현했다.

## 2. BOJ_7432 디스크 트리 [(백준 링크)](https://www.acmicpc.net/problem/7432) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/7000/Main_7432.java)

### 문제 요약

디스크에 저장된 디렉토리의 경로가 문자열로 주어졌을 때 정렬하여 사전순으로 출력하고, 하위 디렉토리는 부모 디렉토리보다 한 칸씩 띄어쓰기 후 출력하도록 구현하는 문제

### 풀이 아이디어

트라이를 구성할 때 각각의 문자열을 Map에 저장하는 방식으로 구현하면 된다. 이 때, 사전순으로 출력해야 하기 때문에 미리 정렬된 상태를 유지하도록 TreeMap을 통해 구현해주었다.

## 3. BOJ_16901 XOR MST [(백준 링크)](https://www.acmicpc.net/problem/16901) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/16000/Main_16901.java)

### 문제 요약

N 개의 정수가 주어지고, 각 정수를 정점으로 하고 간선의 가중치는 정수 값의 XOR로 계산하는 MST를 구성할 때 가중치의 비용을 계산하는 문제.

### 풀이 아이디어

입력으로 들어오는 정수의 크기는 2<sup>30</sup>보다 작기 때문에 모든 수를 길이가 30인 이진수로 변환하여 트라이에 저장하는 방식으로 구현.  
XOR의 최솟값을 계산할 때는 기본적으로 현재 정수 값의 이진수가 트라이의 노드에 연결되어 있지 않은 경우 XOR 연산 값에 추가하고, 연결되어 있다면 그대로 자식 노드로 이동하도록 계산하면 된다.  
다만, 일반적인 방식으로 MST에 연결할 정수를 구하면 $O(N^2)$ 이므로 시간 초과가 발생한다.  
따라서 분할 정복을 통해 값을 계산해야 하는데, 각 이진수의 자리수 별로 트라이의 왼쪽 자식 노드, 오른쪽 자식 노드에서 재귀적으로 연결할 때 필요한 비용을 계산하도록 한 뒤 양쪽의 트라이를 비교하여 두 트라이를 연결하는 최소 XOR 값을 찾는 방식으로 해결해야 한다.  
두 트라이를 비교할 때는 DFS를 통해 리프 노드까지 내려가는 과정에서 값이 같은 경우가 없는 이진수 Index를 찾아 XOR 값을 계산하도록 수행했다. 추가로, 왼쪽 트라이, 오른쪽 트라이 모두에 자식 노드가 2개씩 있는 경우 왼쪽으로 갔을 때의 XOR 값과 오른쪽으로 갔을 때의 XOR 값을 비교하여 더 작은 값을 찾도록 수행해줘야 한다.

## 4. BOJ_10538 빅 픽쳐 [(백준 링크)](https://www.acmicpc.net/problem/10538) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10538.java)

### 문제 요약

o, x로 구성된 걸작이 주어지고, 패턴으로 사용할 그림이 주어질 때 걸작에 패턴 그림이 몇 개 존재하는지 계산하는 문제

### 풀이 아이디어

2차원으로 구성된 문자열 값이 같은지 확인해야 하기 때문에, 입력으로 주어진 패턴 그림 문자열을 [트라이](#trie-트라이)에 넣으면서, 리프 노드인 경우 해시 값을 기록하도록 설정하여 문자열을 정수로 해싱하였다.  
이후 각각의 걸작 문자열을 트라이와 비교하면서 일치하는 부분이 있다면 해시 값으로 변환하여 걸작을 2차원 정수 배열로 변환하였다. [(아호-코라식 알고리즘)](https://github.com/rldnjs7723/CodingTest#aho-corasick-아호-코라식-알고리즘)  
2차원 정수 배열로 변환한 문자열을 이번에는 열을 기준으로 하나의 문자열로 인식하여 [KMP 알고리즘](https://github.com/rldnjs7723/CodingTest#knuth-morris-pratt-kmp-pattern-matching)를 정수 배열에 적용하는 방식으로 패턴 매칭을 수행하였고, 이를 통해 패턴 그림과 일치하는 부분 문자열 배열의 개수를 셀 수 있었다.

![빅픽쳐](https://user-images.githubusercontent.com/20474034/233145976-1d02a3e4-e167-4a41-bd94-b52813357b2d.png)
