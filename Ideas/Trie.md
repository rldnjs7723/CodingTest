# 트라이 문제 정리

## 목차

1. [BOJ_27652 AB](#1-boj_27652-ab-백준-링크-소스-코드)
2. [BOJ_7432 디스크 트리](#2-boj_7432-디스크-트리-백준-링크-소스-코드)
3. [BOJ_16901 XOR MST](#3-boj_16901-xor-mst-백준-링크-소스-코드)
4. [BOJ_10538 빅 픽쳐](#4-boj_10538-빅-픽쳐-백준-링크-소스-코드)
5. [SWEA_13461 이미지 검색하기](#5-swea_13461-이미지-검색하기-소스-코드)
6. [BOJ_5670 휴대폰 자판](#6-boj_5670-휴대폰-자판-백준-링크-소스-코드)
7. [BOJ_19585 전설](#7-boj_19585-전설-백준-링크-소스-코드)

## 1. BOJ_27652 AB [(백준 링크)](https://www.acmicpc.net/problem/27652) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/27000/Main_27652.java)

### 문제 요약

두 문자열 집합 A, B가 있을 때 A, B에 문자열을 넣고 삭제하는 쿼리가 주어진다. A의 원소에서는 접두사를, B의 원소에서는 접미사를 합쳤을 때 입력 받은 문자열이 되는 경우의 수를 계산하는 쿼리 또한 주어진다.

### 풀이 아이디어

전형적인 트라이 문제. 입력은 영어 소문자로만 들어오기 때문에 문자열의 각 문자를 각각의 노드에 저장하는 방식으로 트라이를 구성해주면 된다. 다만, B의 경우 접미사를 사용해야 하기 때문에 원래 입력 받은 문자열을 역순으로 트라이에 넣어주는 방식으로 구현했다.  
경우의 수를 계산할 때는 반복되는 계산을 피하기 위해 각각의 접두사에 해당하는 개수를 한 번에 계산한 뒤 배열로 리턴하여 계산하도록 구현했다.

## 2. BOJ_7432 디스크 트리 [(백준 링크)](https://www.acmicpc.net/problem/7432) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/7000/Main_7432.java)

### 문제 요약

디스크에 저장된 디렉토리의 경로가 문자열로 주어졌을 때 정렬하여 사전순으로 출력하고, 하위 디렉토리는 부모 디렉토리보다 한 칸씩 띄어쓰기 후 출력하도록 구현하는 문제

### 풀이 아이디어

트라이를 구성할 때 각각의 문자열을 Map에 저장하는 방식으로 구현하면 된다. 이 때, 사전순으로 출력해야 하기 때문에 미리 정렬된 상태를 유지하도록 TreeMap을 통해 구현해주었다.

## 3. BOJ_16901 XOR MST [(백준 링크)](https://www.acmicpc.net/problem/16901) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/16000/Main_16901.java)

### 문제 요약

N 개의 정수가 주어지고, 각 정수를 정점으로 하고 간선의 가중치는 정수 값의 XOR로 계산하는 MST를 구성할 때 가중치의 비용을 계산하는 문제.

### 풀이 아이디어

입력으로 들어오는 정수의 크기는 2<sup>30</sup>보다 작기 때문에 모든 수를 길이가 30인 이진수로 변환하여 트라이에 저장하는 방식으로 구현.  
XOR의 최솟값을 계산할 때는 기본적으로 현재 정수 값의 이진수가 트라이의 노드에 연결되어 있지 않은 경우 XOR 연산 값에 추가하고, 연결되어 있다면 그대로 자식 노드로 이동하도록 계산하면 된다.  
다만, 일반적인 방식으로 MST에 연결할 정수를 구하면 $O(N^2)$ 이므로 시간 초과가 발생한다.  
따라서 분할 정복을 통해 값을 계산해야 하는데, 각 이진수의 자리수 별로 트라이의 왼쪽 자식 노드, 오른쪽 자식 노드에서 재귀적으로 연결할 때 필요한 비용을 계산하도록 한 뒤 양쪽의 트라이를 비교하여 두 트라이를 연결하는 최소 XOR 값을 찾는 방식으로 해결해야 한다.  
두 트라이를 비교할 때는 DFS를 통해 리프 노드까지 내려가는 과정에서 값이 같은 경우가 없는 이진수 Index를 찾아 XOR 값을 계산하도록 수행했다. 추가로, 왼쪽 트라이, 오른쪽 트라이 모두에 자식 노드가 2개씩 있는 경우 왼쪽으로 갔을 때의 XOR 값과 오른쪽으로 갔을 때의 XOR 값을 비교하여 더 작은 값을 찾도록 수행해줘야 한다.

## 4. BOJ_10538 빅 픽쳐 [(백준 링크)](https://www.acmicpc.net/problem/10538) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/10000/Main_10538.java)

### 문제 요약

o, x로 구성된 걸작이 주어지고, 패턴으로 사용할 그림이 주어질 때 걸작에 패턴 그림이 몇 개 존재하는지 계산하는 문제

### 풀이 아이디어

2차원으로 구성된 문자열 값이 같은지 확인해야 하기 때문에, 입력으로 주어진 패턴 그림 문자열을 [트라이](#trie-트라이)에 넣으면서, 리프 노드인 경우 해시 값을 기록하도록 설정하여 문자열을 정수로 해싱하였다.  
이후 각각의 걸작 문자열을 트라이와 비교하면서 일치하는 부분이 있다면 해시 값으로 변환하여 걸작을 2차원 정수 배열로 변환하였다. [(아호-코라식 알고리즘)](https://github.com/rldnjs7723/CodingTest#aho-corasick-아호-코라식-알고리즘)  
2차원 정수 배열로 변환한 문자열을 이번에는 열을 기준으로 하나의 문자열로 인식하여 [KMP 알고리즘](https://github.com/rldnjs7723/CodingTest#knuth-morris-pratt-kmp-pattern-matching)를 정수 배열에 적용하는 방식으로 패턴 매칭을 수행하였고, 이를 통해 패턴 그림과 일치하는 부분 문자열 배열의 개수를 셀 수 있었다.

![빅픽쳐](https://user-images.githubusercontent.com/20474034/233145976-1d02a3e4-e167-4a41-bd94-b52813357b2d.png)

## 5. SWEA_13461 이미지 검색하기 [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/13000/Solution_13461.java)

### 문제 요약

N개의 이미지가 주어져있고, 이후에 하나의 이미지가 주어졌을 때 해당 이미지와 가장 비슷한 이미지의 ID를 출력하는 문제

### 풀이 아이디어

처음 N개의 이미지가 주어질 때 모든 이미지를 하나의 Tree에 이진 트리 형식으로 저장하고, 이후 하나의 이미지와 가장 비슷한 이미지를 찾을 때는 백트래킹을 통해 탐색에 걸리는 시간 복잡도를 줄였다.

## 6. BOJ_5670 휴대폰 자판 [(백준 링크)](https://www.acmicpc.net/problem/5670) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/5000/Main_5670.java)

### 문제 요약

사전에 여러 개의 단어가 주어졌을 때, 각 단어를 입력하기 위한 평균 입력 횟수를 계산하는 문제. 단어를 입력할 때 중간 부분에서 입력할 수 있는 단어가 하나밖에 없다면 다음 문자는 자동 완성해준다.

### 풀이 아이디어

사전에 있는 단어들을 Trie에 저장한 뒤, 입력한 단어가 리프 노드에 위치해 있거나 (사전에 존재하는 단어) 다른 알파벳으로 시작하는 존재하는 경우 직접 입력하여 카운트를 늘리는 방식으로 계산

## 7. BOJ_19585 전설 [(백준 링크)](https://www.acmicpc.net/problem/19585) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/19000/Main_19585.java)

### 문제 요약

색상 목록, 닉네임 목록이 주어지고, 팀명의 목록이 주어졌을 때 각 팀명이 색상 + 닉네임 순서로 구성되었는지 판단하는 문제.

### 풀이 아이디어

색상 목록은 Trie에 저장하고, 닉네임 목록은 HashSet에 저장. 팀명의 문자를 하나씩 입력하면서 해당 색상이 존재하는지 Trie를 통해 찾고, 나머지 뒷부분은 substring을 통해 잘라낸 뒤 Set에 존재하는지 탐색하는 방식으로 구현.  
닉네임 목록을 Trie에 역순으로 저장하는 방법으로도 구현이 가능하지만, 자바에서는 해당 방식으로 구현하면 시간 초과가 발생하였기 때문에 닉네임은 HashSet으로 저장.
