# 완전 탐색 알고리즘 문제 정리

## 목차

1. [SWEA_1953 탈주범 검거](#1-swea_1953-탈주범-검거-swea-링크-소스-코드)
2. [BOJ_2615 오목](#2-boj_2615-오목-백준-링크-소스-코드)
3. [BOJ_13913 숨바꼭질 4](#3-boj_13913-숨바꼭질-4-백준-링크-소스-코드)
4. [BOJ_13023 ABCDE](#4-boj_13023-abcde-백준-링크-소스-코드)
5. [BOJ_15683 감시](#5-boj_15683-감시-백준-링크-소스-코드)

## 1. SWEA_1953 탈주범 검거 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/1000/Solution_1953.java)

### 문제 요약

지하 터널 구조와 파이프 별 이동 가능한 상황, 경과한 시간이 주어졌을 때 탈주범이 존재할 수 있는 영역의 개수를 세는 문제

### 풀이 아이디어

기본적인 사방 탐색 + BFS로 문제 해결.  
[백준 16946 벽 부수고 이동하기 4](#1-boj_16946-벽-부수고-이동하기-4-백준-링크-소스-코드)와 같이 객체를 통해 방문 체크를 수행

## 2. BOJ_2615 오목 [(백준 링크)](https://www.acmicpc.net/problem/2615) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/2000/Main_2615.java)

### 문제 요약

바둑판의 상태가 주어졌을 때 흑이 이겼는지, 백이 이겼는지 판단하고 오목이 존재한다면 가장 왼쪽에 위치한 돌의 행, 열을 출력하는 문제.

### 풀이 아이디어

기본적으로 오른쪽, 아래, 오른쪽 아래, 왼쪽 아래로 탐색하면서 오목이 존재하는지 찾아야 함. 각 돌에서 이미 확인한 방향의 경우 비트마스크를 통해 각 방향을 탐색했는지 표시함.  
이렇게 구현했기 때문에 왼쪽 아래로 탐색을 수행하는 경우 행, 열을 출력할 때 마지막 돌의 위치를 출력하는 예외 처리를 수행해야 했음. `조건을 항상 잘 읽어보자.`

## 3. BOJ_13913 숨바꼭질 4 [(백준 링크)](https://www.acmicpc.net/problem/13913) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/13000/Main_13913.java)

### 문제 요약

현재 위치의 x2, +1, -1의 위치로 이동할 수 있을 때 동생에게 이동하는 최소 이동 수와 이동 경로를 출력하는 문제

### 풀이 아이디어

BFS로 시작 위치부터 모든 이동을 수행해보며, 이동 최소 횟수가 갱신되는 경우에만 해당 위치에서 다음 위치로 탐색을 수행하도록 진행했을 때, 동생의 위치에 가장 먼저 도착할 때가 최소 이동 횟수.  
갱신한 경우에 이전에 있었던 위치를 기록해두면 이동 경로도 역순으로 쉽게 찾을 수 있다.

## 4. BOJ_13023 ABCDE [(백준 링크)](https://www.acmicpc.net/problem/13023) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/13000/Main_13023.java)

### 문제 요약

그래프를 DFS로 탐색했을 때 깊이가 4 이상인 경우가 존재하는지 확인하는 문제

### 풀이 아이디어

그래프에서 각 정점의 방문 체크를 수행하며 DFS를 수행할 수 있다면 해결 가능

## 5. BOJ_15683 감시 [(백준 링크)](https://www.acmicpc.net/problem/15683) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/15000/Main_15683.java)

### 문제 요약

CCTV의 위치와 종류가 기록된 상태 공간이 주어졌을 때, 해당 CCTV의 방향을 바꿔가며 생기는 사각 지대 영역의 최솟값을 구하는 문제

### 풀이 아이디어

`각 CCTV가 바라보는 방향에 따라 감시 할 수 있는 방향에 대한 정보를 미리 배열로 정리해 두고`, CCTV가 바라보는 방향을 하나씩 바꿔가면서 DFS로 완전 탐색을 수행하면 된다.

## 6. BOJ_1090 체커 [(백준 링크)](https://www.acmicpc.net/problem/1090) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1090.java)

### 문제 요약

N <= 50개의 체커의 좌표가 주어졌을 때 한 점으로 모으는 최소 이동 횟수를 계산하는 문제

### 풀이 아이디어

분류가 브루트포스 알고리즘인데, 단순히 생각하여 25개의 체커를 한 점으로 모을 때 최소 이동 횟수를 구하는 과정에서 50C25로 계산하면 바로 메모리와 시간이 터져버린다.  
브루트포스를 수행할 때, 단순히 문제에서 주어진대로만 생각하지 말고 같은 조건을 더 빠르게 구할 수 있는 방법을 알아내야 한다.  
이 문제에서는 모든 (x축 좌표와 각 x축 좌표 사이의 중점, y축 좌표와 각 y축 좌표 사이의 중점)으로 체커를 모으는 최소 이동 횟수를 계산하는 방식으로 해결하면 최대 99 x 99 형태의 x, y 좌표에 대해서만 계산하면 되기 때문에 시간복잡도가 획기적으로 줄어들게 된다.  
이는 두 점을 하나의 점으로 모으고자 할 때, 두 점 사이의 어떤 점으로 모으더라도 이동 횟수는 동일하다는 점에서 착안한 방법이다.
