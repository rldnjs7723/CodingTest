# 자료 구조 문제 정리

## 목차

1. [BOJ_9935 문자열 폭발](#1-boj_9935-문자열-폭발-백준-링크-소스-코드)
2. [SWEA_13072 병사관리](#2-swea_13072-병사관리-swea-링크-소스-코드)
3. [SWEA_5644 무선 충전](#3-swea_5644-무선-충전-swea-링크-소스-코드)
4. [BOJ_16236 아기 상어](#4-boj_16236-아기-상어-백준-링크-소스-코드)
5. [BOJ_14865 곡선 자르기](#5-boj_14865-곡선-자르기-백준-링크-소스-코드)
6. [BOJ_21611 마법사 상어와 블리자드](#6-boj_21611-마법사-상어와-블리자드-백준-링크-소스-코드)
7. [SWEA_3000 중간값 구하기](#7-swea_3000-중간값-구하기-swea-링크-소스-코드)
8. [BOJ_1725 히스토그램](#8-boj_1725-히스토그램-백준-링크-소스-코드)

## 1. BOJ_9935 문자열 폭발 [(백준 링크)](https://www.acmicpc.net/problem/9935) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/9000/Main_9935.java)

### 문제 요약

문자열 A와 폭탄 문자열 B가 주어졌을 때, 문자열 A안에 포함되어 있는 문자열 B를 공백으로 대체하는 문제.  
문자열 A 내부의 문자열 B가 공백으로 대체된 이후에도 문자열 B가 계속 존재할 수 있다.

### 풀이 아이디어

문자열 A를 `Stack`으로 저장한 뒤, 문자열 B를 역순으로 참조하며 pop한 결과와 비교하면서 문자열 B와 동일하면 해당 문자열을 제거한 뒤 문자열 B의 길이만큼 이전에 확인했던 문자열을 stack에 넣어 다시 확인

## 2. SWEA_13072 병사관리 [(SWEA 링크)](https://swexpertacademy.com/main/talk/codeBattle/problemDetail.do?contestProbId=AXxODdXKQAADFASZ&categoryId=AYYZruxqM7YDFARc&categoryType=BATTLE&battleMainPageIndex=1#none) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/13000/Solution_13072.java)

### 문제 요약

답안을 체크하는 Main 함수가 주어졌을 때, 병사를 관리하는 UserSolution 클래스를 완성하는 문제.  
병사 고용, 병사 해고, 병사의 평판 점수 변경, 특정 팀에 속한 병사들의 평판 점수를 일괄 변경, 특정 팀 안에서 가장 평판 점수가 높은 병사를 검색하는 기능을 구현해야 한다.

### 풀이 아이디어

기본적으로 병사를 고용, 해고, 점수 변경의 작업은 배열을 통해 구현하면 O(1) 시간 내에 수행을 마칠 수 있지만, 특정 팀에 속한 병사의 평판 점수를 일괄 변경하는 작업이 기본적으로 O(N)이었기 때문에 시간 초과가 발생하여 해설을 보고 해결하였다.  
`각 병사의 평판 점수 범위가 1 <= score <= 5이므로 각 팀별로 점수가 1 ~ 5인 병사를 각각 배열로 관리하고, Soldier 클래스를 직접 구현 LinkedList의 노드로 활용하여 점수를 일괄적으로 변경할 때 해당 점수 리스트의 Head 노드부터 Tail 노드까지 전부 다른 점수 리스트의 Tail 뒤에 붙여버리는 방식으로 이 연산 또한 O(1)의 시간 복잡도로 구현할 수 있음을 확인했다.`

## 3. SWEA_5644 무선 충전 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRDL1aeugDFAUo) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/5000/Solution_5644.java)

### 문제 요약

두 사람 A, B가 이동하는 경로가 주어지고, 무선 충전기의 위치와 범위, 성능이 주어졌을 때 두 사람의 충전량 최댓값을 구하는 문제.

### 풀이 아이디어

전반적으로 A, B가 처할 수 있는 모든 경우의 수를 확인하여 각 시간대별 최대 충전량을 계산하면 되는 문제. 충전에 사용할 상위 2개의 충전기를 찾기 위해, 접근 가능한 충전기들을 `TreeSet`을 사용하여 성능을 기준으로 정렬하면 간단하게 해결할 수 있다. (우선 순위 큐로도 구현 가능)  
또한, A와 B가 같은 충전기에 위치했을 때 충전량이 분산된다는 설명이 있는데, 어차피 한 명이 충전량을 다 가져가면 되기 때문에 `의미 없는 조건`

## 4. BOJ_16236 아기 상어 [(백준 링크)](https://www.acmicpc.net/problem/16236) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/16000/Main_16236.java)

### 문제 요약

생선과 상어의 위치와 크기가 주어진 공간이 있을 때, 해당 공간에서 상어가 더 이상 먹을 수 있는 물고기가 없게 되는 시간을 계산하는 문제. 상어는 자신의 크기와 같은 개수의 물고기를 먹으면 크기가 1 증가한다.

### 풀이 아이디어

기본적으로는 BFS를 통해 상어가 먹을 수 있는 가장 가까운 생선을 찾는 문제. 대신 거리가 가까운 생선 중에서 행의 크기와 열의 크기가 가장 작은 생선을 선택해야 하기 때문에, compareTo 메서드를 override하여 정렬 기준을 설정하고, `PriorityQueue`에 넣으면 자동으로 먼저 먹어야 하는 생선을 구할 수 있다.

## 5. BOJ_14865 곡선 자르기 [(백준 링크)](https://www.acmicpc.net/problem/14865) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/14000/Main_14865.java)

### 문제 요약

짝으로 이루어진 두 선분 사이에 다른 선분 짝이 존재하는지, 현재 선분이 다른 선분 짝 내부에 포함되어 있는지 체크하여 그 개수를 카운트하는 문제

### 풀이 아이디어

선분을 입력 받을 때 조건에 따라 각각 짝을 지어주고, 각 선분들을 우선순위 큐에 넣어 X 좌표 기준으로 정렬한다.  
이후 Stack에 자신의 짝이 들어있다면 pop하고, 짝이 없다면 push하는 방식으로 쌓으면서 다른 선분 사이에 포함되어 있는지 / 다른 선분을 포함하는지 체크하여 개수를 센다.

## 6. BOJ_21611 마법사 상어와 블리자드 [(백준 링크)](https://www.acmicpc.net/problem/21611) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/21000/Main_21611.java)

### 문제 요약

나선형 형태로 주어지는 상태 공간에 대하여

1. 특정 행, 열에 위치한 원소를 제거하고, 나선형 위치에서 앞으로 당기는 기능 (구슬 파괴)
2. 연속으로 위치한 숫자가 4개 이상인 경우 해당 숫자를 제거한 뒤 앞으로 당기는 기능 (구슬 폭발)
3. 연속으로 위치한 숫자의 개수를 센 뒤 해당 숫자의 개수 -> 해당 숫자의 종류 순서로 재구성하는 기능 (구슬 변화)

위와 같은 기능을 구현하는 문제

### 풀이 아이디어

`나선형 형태로 주어져 있는 상태를 리스트에 넣어 직선 형태의 자료로 재구성 하는 것이 핵심 아이디어.`  
기능 1의 경우, 나선형 상태에서의 행, 열 위치를 통해 리스트의 몇 번 Index에 저장되어 있는 지 알기 위해 추가로 배열에 Index를 나타내주어야 한다.  
기능 2와 3의 경우 임의의 Index에 데이터를 추가, 삭제를 수행해줘야 하는 작업이기 때문에 리스트를 활용한 연산이 가장 간단하다고 판단.

## 7. SWEA_3000 중간값 구하기 [(SWEA 링크)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV-fO0s6ARoDFAXT) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/SWEA/3000/Solution_3000.java)

### 문제 요약

초기 수를 하나 입력 받고, 이후 수를 2개씩 입력 받을 때, 입력 받은 후의 중간값을 전부 더하여 20171109로 나눈 나머지를 계산하는 문제.

### 풀이 아이디어

처음에 입력받은 값을 중간값으로 두고, 중간값보다 작은 수는 최대힙에, 큰 수는 최소힙에 넣어 주면 중간값을 유지 할 수 있다.  
이 때, 두 힙의 균형이 깨진다면 크기가 더 큰 힙에서 뽑은 값을 중간 값으로 설정하고, 기존의 중간값은 크기가 작은 힙으로 넣으면 균형을 유지하여 중간값을 빠르게 계산할 수 있다.

## 8. BOJ_1725 히스토그램 [(백준 링크)](https://www.acmicpc.net/problem/1725) [(소스 코드)](https://github.com/rldnjs7723/CodingTest/blob/main/BOJ/1000/Main_1725.java)

### 문제 요약

히스토그램 각 위치의 높이가 주어질 때, 히스토그램에서 존재하는 가장 큰 직사각형의 넓이를 계산하는 문제

### 풀이 아이디어

Stack에 저장되어 있는 막대의 높이가 현재 높이보다 작다면 Stack에 Push하고, 현재 높이보다 크다면 Stack에서 Pop하여 넓이 계산 후 최대 넓이를 갱신해서 해결.  
또한 마지막으로 Pop한 높이의 Index로 현재 높이의 시작지점을 설정해줘야 현재 높이의 직사각형을 계산할 수 있다.
